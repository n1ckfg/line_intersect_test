<!DOCTYPE html>
<html>
	<!-- https://discourse.threejs.org/t/solved-how-to-find-intersection-between-two-rays/6464/6 -->
	<!-- http://threejs.hofk.de/LinesDistance/LinesDistance.html -->
	<head>
	    <title>LinesDistance</title>
	    <meta charset="utf-8">
		<script src="./js/libraries/three.min.js"></script>
		<script src="./js/libraries/OrbitControls.js"></script>
	</head>

	<body>
		mp.x <input type="range" id="mpx" min="0" max="1" value="0.725" step="0.0001" style="width: 90%;"> 
		<div id="distance"></div> 
		<div id="Pn"></div> 
		<div id="Qn"></div>

		<script>
			// based on demo by @hofk
			"use strict";

			function readJson(url, callback) {
				let xobj = new XMLHttpRequest();
	            xobj.overrideMimeType("application/json");
	            xobj.open('GET', url, true);
	            xobj.onreadystatechange = function() {
	                if (xobj.readyState == 4 && xobj.status == "200") {
	                    callback(xobj.responseText);
	                }
	            };
	            xobj.send(null);  
			}

			function randomColorString() {
				let base = 192;
				let rand = 255 - base;
				let r = parseInt(base + Math.random() * rand);
				let g = parseInt(base + Math.random() * rand);
				let b = parseInt(base + Math.random() * rand);
				return "rgb(" + r + "," + g + "," + b + ")"
			}

			const scale = 20;

			class Eye {

				constructor(_name, _position, _rotation, _width, _height, _focal, _k1, _k2) {
					this.name = _name;

					this.position = _position.multiplyScalar(scale);
					this.rotation = _rotation;
					this.width = _width;
					this.height = _height;
					this.focal = _focal;
					this.k1 = _k1;
					this.k2 = _k2;

					this.color = randomColorString();
										
					this.origin = this.createLine(new THREE.Vector3(0,0,0), new THREE.Vector3(0,-scale*10,0));
					this.plane = this.createPlane(new THREE.Vector3(0,-scale*2,0));

					this.geometry = new THREE.ConeBufferGeometry(scale/6, scale/3, 4);
					this.geometry.rotateY(Math.PI/4);
					this.material = new THREE.MeshBasicMaterial({color: this.color});
					this.mesh = new THREE.Mesh(this.geometry, this.material);

					this.mesh.add(this.origin);
					this.mesh.add(this.plane);

					this.mesh.position.set(this.position.x, this.position.y, this.position.z);
					this.mesh.rotation.set(this.rotation.x, this.rotation.y, this.rotation.z);
					this.points = [];
				}

				createPlane(pos) {
					let scaleX = scale;
					let scaleY = scale;
					if (this.width > this.height) {
						scaleX = (this.width/this.height) * scale;
					} else if (this.height > this.width) {
						scaleY = (this.height/this.width) * scale;
					}
					let geo = new THREE.PlaneGeometry(scaleX, scaleY, 1);
					geo.rotateX(Math.PI/2);
					let mtl = new THREE.MeshBasicMaterial({color: this.color, side: THREE.DoubleSide});
					let plane = new THREE.Mesh(geo, mtl);
					plane.position.set(pos.x, pos.y, pos.z);
					return plane;
				}

				createLine(start, end) {
					let geo = new THREE.BufferGeometry();
					geo.positions = new Float32Array(6);
					geo.setAttribute("position", new THREE.BufferAttribute(geo.positions, 3));
					let mtl = new THREE.LineBasicMaterial({ color: this.color, side: THREE.DoubleSide });
					let line = new THREE.Line(geo, mtl);

					geo.positions[0] = start.x;
					geo.positions[1] = start.y;
					geo.positions[2] = start.z;

					geo.positions[3] = start.x + end.x;
					geo.positions[4] = start.y + end.y;
					geo.positions[5] = start.z + end.z;

					return line;
				}

			}

			let eyes = [];
			let ready = false;

			readJson("./files/opensfm.json", function(response) {
	            let json = JSON.parse(response)[0];

	            for (let el in json["shots"]) {
	            	let name = el.split("_")[0];
	            	let eyeEl = json["shots"][el];

	            	let px = eyeEl.translation[0];
	            	let py = eyeEl.translation[1];
	            	let pz = eyeEl.translation[2];
		           	let position = new THREE.Vector3(px, py, pz);

	            	let rx = eyeEl.rotation[0];
	            	let ry = eyeEl.rotation[1];
	            	let rz = eyeEl.rotation[2];
	         		let rotation = new THREE.Vector3(rx, ry, rz);

					let eyeElCamera = json["cameras"][eyeEl["camera"]];
					let width = eyeElCamera.width;
					let height = eyeElCamera.height;
					let focal = eyeElCamera.focal;
					let k1 = eyeElCamera.k1;
					let k2 = eyeElCamera.k2;

					let eye = new Eye(name, position, rotation, width, height, focal, k1, k2);
					console.log("Created eye " + name);
					eyes.push(eye);	            	
	            }

	            ready = true;
			});

			let mpx = document.getElementById('mpx');
			mpx.onchange = refresh;

			let dpnqnDet, pnDet, qnDet; // uses determinant
			let dpnqnCr, pnCr, qnCr; // uses cross vectors
			let dist; // uses formula distance

			let scene = new THREE.Scene();
			let camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.position.set(0, 10, 40);
			let renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0xaaaaaa, 1);	
			let container = document.createElement('div');
			document.body.appendChild(container);
			container.appendChild(renderer.domElement); 
			let controls = new THREE.OrbitControls(camera, renderer.domElement);

			let axesHelper = new THREE.AxesHelper(28);
			scene.add(axesHelper);
			let grid = new THREE.GridHelper(50, 50);
			scene.add(grid);

			let gLineP = new THREE.BufferGeometry();
			gLineP.positions = new Float32Array(6);
			gLineP.setAttribute('position', new THREE.BufferAttribute(gLineP.positions, 3).setDynamic(true));
			let lineP = new THREE.Line(gLineP, new THREE.LineBasicMaterial({ color: 0x00ffff, side: THREE.DoubleSide }));

			let p = new THREE.Vector3(-15, 12, -5);
			let mp = new THREE.Vector3(35, -8 , 15); // mp.x can be changed with slider

			gLineP.positions[0] = p.x;
			gLineP.positions[1] = p.y;
			gLineP.positions[2] = p.z;

			gLineP.positions[3] = p.x + mp.x;
			gLineP.positions[4] = p.y + mp.y;
			gLineP.positions[5] = p.z + mp.z;

			scene.add(lineP);

			let gLineQ = new THREE.BufferGeometry();
			gLineQ.positions = new Float32Array(6);
			gLineQ.setAttribute('position', new THREE.BufferAttribute(gLineQ.positions, 3));
			let lineQ = new THREE.Line(gLineQ, new THREE.LineBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide }));
			let q = new THREE.Vector3(-12, 14, -15);
			let mq = new THREE.Vector3(34, -12, 33);

			gLineQ.positions[0] = q.x;
			gLineQ.positions[1] = q.y;
			gLineQ.positions[2] = q.z;

			gLineQ.positions[3] = q.x + mq.x;
			gLineQ.positions[4] = q.y + mq.y;
			gLineQ.positions[5] = q.z + mq.z;

			scene.add(lineQ);

			refresh();

			animate();

			function animate() {
				requestAnimationFrame(animate);
				renderer.render(scene, camera);
				controls.update();

				if (ready) {
					for (let eye of eyes) {
						scene.add(eye.mesh);
					}
					ready = false;
				}
			}

			function linesDistance() { // mp and mq    non-collinear
				let pq = new THREE.Vector3().subVectors(q, p);
				let n = new THREE.Vector3().crossVectors(mp, mq).normalize();
				let d = pq.dot(n);
				
				return Math.abs(d);
			} 

			function closestPointsDet() { // mp and mq    non-collinear
				// using determinant
			 	let qp = new THREE.Vector3().subVectors(p, q);
				
				let qpDotmp = qp.dot(mp);
				let qpDotmq = qp.dot(mq);
				let mpDotmp = mp.dot(mp);
				let mqDotmq = mq.dot(mq);
				let mpDotmq = mp.dot(mq);	
				
				let detp = qpDotmp * mqDotmq - qpDotmq * mpDotmq;
				let detq = qpDotmp * mpDotmq - qpDotmq * mpDotmp;
				
				let detm = mpDotmq * mpDotmq - mqDotmq * mpDotmp; 
				
				pnDet = p.clone().add(mp.clone().multiplyScalar(detp / detm));
				qnDet = q.clone().add(mq.clone().multiplyScalar(detq / detm));
				
				dpnqnDet = pnDet.clone().sub(qnDet).length();	
			}

			function closestPointsCross() { // mp and mq    non-collinear
				// using cross vectors
				let qp = new THREE.Vector3().subVectors(p, q);
				let pq = qp.clone().multiplyScalar(-1);
				
				let npq = new THREE.Vector3().crossVectors(mp, mq).normalize();
				let nqp = new THREE.Vector3().crossVectors(mq, mp).normalize();
				
				let n1 = new THREE.Vector3().crossVectors(mp, nqp).normalize();
				let n2 = new THREE.Vector3().crossVectors(mq, npq).normalize();
				
				let qpDotn1 = qp.dot(n1);
				let pqDotn2 = pq.dot(n2);
				
				let mpDotn2 = mp.dot(n2);
				let mqDotn1 = mq.dot(n1);
					
				pnCr = p.clone().add(mp.clone().multiplyScalar(pqDotn2 / mpDotn2)); 
				qnCr = q.clone().add(mq.clone().multiplyScalar(qpDotn1 / mqDotn1)); 
				
				dpnqnCr = pnCr.clone().sub(qnCr).length();
			}

			function refresh() { 
				mp.x = mpx.value * 50;
				
				gLineP.positions[3] = p.x + mp.x;
				gLineP.attributes.position.needsUpdate = true;
				
				closestPointsDet();	
				closestPointsCross();
				
				Pn.innerHTML = ' Pn Det (' + pnDet.x + ', '+ pnDet.y + ', '+ pnDet.z + ') <==> Pn Cr (' + pnCr.x + ', '+ pnCr.y + ', '+ pnCr.z + ') ';
				Qn.innerHTML = ' Qn Det (' + qnDet.x + ', '+ qnDet.y + ', '+ qnDet.z + ') <==> Qn Cr (' + qnCr.x + ', '+ qnCr.y + ', '+ qnCr.z + ') ';	
				
				dist = linesDistance();	
				distance.innerHTML = 'distance: dPQ Determinant: ' + dpnqnDet +    '    <==>     function linesDistance() :' + dist + '     <==> dPQ Cross: ' + dpnqnCr;
			}
		</script>
	</body>

</html>